{
  "A0010": {
    "title": "终端异常环境检测",
    "category": "AC02",
    "summary": "对应用运行环境及用户请求环境进行识别，发现异常环境。",
    "description": "异常环境识别通过获取包括不限于终端静默人机挑战、应用合法性、进程合法性、是否越狱（ROOT）、陀螺仪状态、是否外挂插件等数十种数据的获取、分析和判断。业务场景下的异常环境识别一般是通过业务终端访问系统实现的。根据业务访问模式的不同，终端访问系统可能是浏览器、APP移动应用、桌面级程序等形式。异常环境识别能力严重依赖业务终端访问系统的权限，由于用户授权限制以及法律法规限制，异常环境识别具有一定的局限性，且也受到对抗和终端数据完整性制约。",
    "limitation": "因为异常环境检测都是在用户可控的终端上展开的，所以最终效果取决于对抗性。从理论上讲，因为终端可控，那么就总是能够绕过各种异常环境检测策略，最终就是个时间成本与能力高低问题。",
    "references": [],
    "updated": "2024-01-11"
  },
  "A0010-001": {
    "title": "手机模拟器检测",
    "category": "AC02",
    "summary": "对APP是否运行在手机模拟器上进行识别",
    "description": "模拟器常常被用来刷单，如何准确的识别模拟器成为App开发中的一个重要模块，目前也有专门的公司提供相应的SDK供开发者识别模拟器。 目前流行的Android模拟器大概分为两种，一种是基于Qemu，另一类是基于Genymotion(VirtualBox类)，网上现在流行用一些模拟器特征进行鉴别，比如：通过判断IMEI是否全部为0000000000格式；判断Build中的一些模拟器特征值；匹配Qemu的一些特征文件以及属性；通过获取cpu信息，将x86的给过滤掉（真机一般都是基于ARM）等",
    "limitation": "手机模拟器检测的对抗点有两处：一是对APP采集的信息提前进行伪造，二是对APP采集后上传的信息进行伪造。",
    "references": [
      {
        "title": "Android模拟器识别检测技术",
        "description": "",
        "link": "https://blog.csdn.net/liuno0/article/details/124279075"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-002": {
    "title": "云手机检测",
    "category": "AC02",
    "summary": "对APP是否运行在云手机上进行识别",
    "description": "可以通过识别手机模拟器（A010-001）的方式来进行云手机识别，此外设备指纹、异常环境监测、出网IP等也可用来进行云手机识别。由于云手机通常不能修改ROM，大部分甚至不能获得ROOT权限，所以对抗效果通常会好于手机模拟器检测（A010-001）",
    "limitation": "随着云手机、云游戏的不断发展和普及，APP厂商将不能采用“云”即是“黑”的一棒子打死的策略，否则将面临大量用户投诉，这为未来黑产利用云手机留下了空间。",
    "references": [],
    "updated": "2024-01-11"
  },
  "A0010-003": {
    "title": "手机ROOT/越狱检测",
    "category": "AC02",
    "summary": "对APP是否运行在被Root或越狱破解的设备上进行识别",
    "description": "通过Root或越狱后的特征来进行判断，譬如：可以查看发布的系统版本，是test-keys（测试版），还是release-keys（发布版）；检查是否存在Superuser.apk；检测在常用目录下是否存在su；使用which命令查看是否存在su；执行su，看能否获取到root权限；是否存在busybox；访问/data目录，查看读写权限等",
    "limitation": "对于ROOT机反检测有两种策略：其一是对应用下手，干预应用的ROOT检测行为；另外一个思路则是对系统下手，隐藏系统自身ROOT相关的特征。通过还原手机ROOT检测的每一条策略和规则，就能提前预制反检测策略。譬如开源的RootCloak就可以通过hook调用api的函数用来对抗root监测",
    "references": [
      {
        "title": "Android root检测方法小结",
        "description": "",
        "link": "https://www.lmlphp.com/user/58076/article/item/637693/"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-004": {
    "title": "外挂检测",
    "category": "AC02",
    "summary": "对程序是否被注入运行时指令或外挂程序进行识别",
    "description": "通过对程序运行时进行完整性校验、关键词或DLL列表检测，对进行列表、窗口标题关键词等进行判断来检测是否存在外挂程序",
    "limitation": "与手机ROOT/越狱检测（A010-003）的局限性一样，通过分析并还原检测过程，阻断或提供Hook后的虚假值即可绕过外挂检测策略。不过因外挂通常用在游戏中，而游戏的数据包可读性比基于HTTP协议的APP应用差许多，如果将外挂检测逻辑和数据回传隐藏在正常的游戏运行和通信中，将加大外挂反检测的难度。",
    "references": [
      {
        "title": "浅谈外挂常识和如何防御",
        "description": "",
        "link": "https://zhuanlan.zhihu.com/p/490189706"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-005": {
    "title": "多开检测",
    "category": "AC02",
    "summary": "对APP是否在终端上被多开进行识别",
    "description": "游戏多开检测只是对游戏的进程数进行限制，分为事前检测、事中检测、和事后检测。事中检测和事后检测往往没有提示，是游戏公司封号、处罚的手段，事前检测即禁止游戏多开，包括：枚举进程的多开检测、互斥对象多开检测、信号量多开检测、窗口多开检测、共享内存检测多开等方法",
    "limitation": "通过分析并还原检测过程，阻断或提供Hook后的虚假值即可绕过多开检测策略。",
    "references": [
      {
        "title": "游戏多开检测的几种实现方法及破解方法参考",
        "description": "",
        "link": "https://blog.csdn.net/weixin_40582034/article/details/125960599"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-006": {
    "title": "调试器检测",
    "category": "AC02",
    "summary": "对程序是否运行被调试进行识别",
    "description": "最基本的调试器检测技术就是检测进程环境块(PEB)中的BeingDebugged标志。PEB另一个成员被称作NtGlobalFlag（偏移0x68），壳也通过它来检测程序是否用调试器加载。Kernel32!CheckRemoteDebuggerPresent()是另一个可以用于确定是否有调试器被附加到进程的API。在调试器中步过INT3和INT1指令的时候，由于调试器通常会处理这些调试中断，所以异常处理例程默认情况下将不会被调用，Debugger Interrupts就利用了这个事实。这样壳可以在异常处理例程中设置标志，通过INT指令后如果这些标志没有被设置则意味着进程正在被调试。更多方式请阅读参考资料。",
    "limitation": "通过分析并还原检测过程，阻断或提供Hook后的虚假值即可绕过调试器检测策略。",
    "references": [
      {
        "title": "脱壳的艺术--2 调试器检测技术",
        "description": "",
        "link": "https://blog.csdn.net/iiprogram/article/details/2248506"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-007": {
    "title": "虚拟机检测",
    "category": "AC02",
    "summary": "对APP是否运行在虚拟机中进行识别",
    "description": "虚拟机运行环境检测，指的是软件能够判断当前是不是在虚拟机中运行，根据判断结果，做对应的处理。从恶意软件的视角，它可以在虚拟机中改变自身行为，加大分析难度。从软件自身安全出发，用于防止被逆向调试以及某些场景下的非正常使用。",
    "limitation": "虚拟机检测方法主要是通过检测一些环境属性和文件，但是这些方法并不是绝对可靠的，因为黑灰产业者可以通过修改虚拟机的环境属性和文件来规避检测",
    "references": [
      {
        "title": "虚拟机运行环境检测",
        "description": "",
        "link": "https://www.cnblogs.com/cherishui/p/14366072.html"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-008": {
    "title": "无头浏览器检测",
    "category": "AC02",
    "summary": "对APP是否运行在无头浏览器中进行识别",
    "description": "无头浏览器检测，指的是软件能够判断当前是不是在无头浏览器中运行，根据判断结果，做对应的处理。从恶意软件的视角，它可以在无头浏览器中改变自身行为，加大分析难度。从软件自身安全出发，用于防止被逆向调试以及某些场景下的非正常使用。",
    "limitation": "无头浏览器检测方法主要是通过检测一些环境属性和文件，但是这些方法并不是绝对可靠的，因为黑灰产业者可以通过修改无头浏览器的环境属性和文件来规避检测",
    "references": [
      {
        "title": "用JavaScript检测当前浏览器是无头浏览器",
        "description": "",
        "link": "https://zhuanlan.zhihu.com/p/149491639"
      }
    ],
    "updated": "2024-01-11"
  },
  "A0010-009": {
    "title": "HOOK检测",
    "category": "AC02",
    "summary": "对APP是否运行在HOOK环境中进行识别",
    "description": "HOOK检测，指的是软件能够判断当前是不是在HOOK环境中运行，根据判断结果，做对应的处理。从恶意软件的视角，它可以在HOOK环境中改变自身行为，加大分析难度。从软件自身安全出发，用于防止被逆向调试以及某些场景下的非正常使用。",
    "limitation": "HOOK检测方法主要是通过检测一些环境属性和文件，但是这些方法并不是绝对可靠的，因为黑灰产业者可以通过修改HOOK环境的环境属性和文件来规避检测",
    "references": [
      {
        "title": "Android hook、检测及对抗相关",
        "description": "",
        "link": "https://blog.csdn.net/jinganggiao/article/details/126932091"
      }
    ],
    "updated": "2024-01-16"
  }
}